rules_version = '2';

/**
 * @name AI-Powered Unified Healthcare Intelligence Platform Security Rules
 * @author Firebase Security Rules Architect
 *
 * @description
 * This ruleset enforces a strict, multi-tenant security model for a healthcare
 * platform connecting patients, doctors, and medicine stores. The rules are
 * designed for robust authorization based on user roles and explicit patient consent.
 *
 * @philosophy
 * Core Philosophy: Access is denied by default. The security model is built on
 * user ownership and role-based data segregation. A user's role (patient, doctor,
 * medicine_store) is determined by the existence of their UID as a document ID in the
 * corresponding top-level collection. All sensitive patient data is nested within that
 * patient's private data tree. Access is granted explicitly based on ownership or
 * a valid, time-bound consent document.
 *
 * @structure
 * Data Structure:
 * - /users/{userId}: A document containing the user's role.
 * - /patients/{patientId}: Private patient profiles and all their nested health data.
 * - /doctors/{doctorId}: Publicly readable doctor profiles.
 * - /medicine_stores/{storeId}: Publicly readable medicine store profiles.
 *
 * @decisions
 * Key Security Decisions:
 * - Role-Based Access: A user's role is not a custom claim but is determined by their
 *   presence in a specific collection (e.g., `exists(/databases/$(database)/documents/doctors/$(request.auth.uid))`).
 * - Patient Privacy by Default: All data under `/patients/{patientId}` is private to that patient.
 * - Consent-Based Sharing: A doctor can only read a patient's data if a valid document
 *   exists in `/patients/{patientId}/data_consents/{doctorId}` which has `consentGiven == true`
 *   and is within the `startDate`/`endDate` window.
 * - Public Discovery: Doctor and Medicine Store profiles are publicly readable to support search features.
 * - Immutable Ownership: Critical ID fields (e.g., patientId, doctorId) are immutable to prevent re-assignment of data.
 *
 * @denormalization
 * Denormalization for Authorization: Appointments and orders are denormalized to allow for
 * simple, path-based ownership checks from multiple roles without complex lookups. For example,
 * an appointment exists under both the patient's and the doctor's data trees.
 */
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(ownerId) {
      return isSignedIn() && request.auth.uid == ownerId;
    }

    function isExistingDoc() {
      return resource != null;
    }

    function isPatient() {
      return exists(/databases/$(database)/documents/patients/$(request.auth.uid));
    }

    function isDoctor() {
      return exists(/databases/$(database)/documents/doctors/$(request.auth.uid));
    }

    function isMedicineStore() {
      return exists(/databases/$(database)/documents/medicine_stores/$(request.auth.uid));
    }

    function doctorHasActiveConsent(patientId) {
      let consentDoc = get(/databases/$(database)/documents/patients/$(patientId)/data_consents/$(request.auth.uid)).data;
      return isDoctor() &&
             consentDoc.consentGiven == true &&
             request.time >= consentDoc.startDate &&
             request.time <= consentDoc.endDate;
    }

    function isCreatingOwnProfile(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    function isIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    function linksToPatientOnCreate(patientId) {
      return request.resource.data.patientId == patientId;
    }
    
    function isPatientLinkImmutable() {
      return request.resource.data.patientId == resource.data.patientId;
    }

    function linksToDoctorOnCreate(doctorId) {
      return request.resource.data.doctorId == doctorId;
    }

    function isDoctorLinkImmutable() {
        return request.resource.data.doctorId == resource.data.doctorId;
    }

    function linksToStoreOnCreate(storeId) {
      return request.resource.data.medicineStoreId == storeId;
    }

    function isStoreLinkImmutable() {
        return request.resource.data.medicineStoreId == resource.data.medicineStoreId;
    }

    // -------------------------------------------------------------------------
    // Profile & Role Rules
    // -------------------------------------------------------------------------
    
    match /users/{userId} {
      allow read, update: if isOwner(userId);
      allow create: if isOwner(userId);
      allow list: if false;
    }

    match /patients/{patientId} {
      allow get: if isOwner(patientId) || doctorHasActiveConsent(patientId);
      allow list: if false; // Prevent querying all patients
      allow create: if isOwner(patientId) && isCreatingOwnProfile(patientId);
      allow update: if isOwner(patientId) && isIdImmutable();
      allow delete: if isOwner(patientId);
    }
    
    match /doctors/{doctorId} {
      allow get, list: if true;
      allow create: if isOwner(doctorId) && isCreatingOwnProfile(doctorId);
      allow update: if isOwner(doctorId) && isIdImmutable();
      allow delete: if isOwner(doctorId);
    }

    match /medicine_stores/{storeId} {
      allow get, list: if true;
      allow create: if isOwner(storeId) && isCreatingOwnProfile(storeId);
      allow update: if isOwner(storeId) && isIdImmutable();
      allow delete: if isOwner(storeId);
    }

    // -------------------------------------------------------------------------
    // Patient Subcollection Rules
    // -------------------------------------------------------------------------
    match /patients/{patientId} {
      match /medical_reports/{reportId} {
        allow get: if isOwner(patientId) || doctorHasActiveConsent(patientId);
        allow list: if isOwner(patientId);
        allow create: if isOwner(patientId) && linksToPatientOnCreate(patientId);
        allow update: if isOwner(patientId) && isPatientLinkImmutable();
        allow delete: if isOwner(patientId);
      }

      match /scan_images/{scanId} {
        allow get: if isOwner(patientId) || doctorHasActiveConsent(patientId);
        allow list: if isOwner(patientId);
        allow create: if isOwner(patientId) && linksToPatientOnCreate(patientId);
        allow update: if isOwner(patientId) && isPatientLinkImmutable();
        allow delete: if isOwner(patientId);
      }

      match /appointments/{appointmentId} {
        allow get, list: if isOwner(patientId) || (isDoctor() && isExistingDoc() && resource.data.doctorId == request.auth.uid);
        allow create: if isOwner(patientId) && linksToPatientOnCreate(patientId);
        allow update: if (isOwner(patientId) || (isDoctor() && isExistingDoc() && resource.data.doctorId == request.auth.uid)) && isPatientLinkImmutable();
        allow delete: if isOwner(patientId);
      }

      match /prescriptions/{prescriptionId} {
        allow get: if isOwner(patientId) || (isDoctor() && isExistingDoc() && resource.data.doctorId == request.auth.uid);
        allow list: if isOwner(patientId);
        allow create: if isDoctor() && linksToPatientOnCreate(patientId) && request.resource.data.doctorId == request.auth.uid;
        allow update, delete: if false; // Prescriptions are immutable
      }

      match /orders/{orderId} {
        allow get: if isOwner(patientId) || (isMedicineStore() && isExistingDoc() && resource.data.medicineStoreId == request.auth.uid);
        allow list: if isOwner(patientId);
        allow create: if isOwner(patientId) && linksToPatientOnCreate(patientId);
        allow update: if (isOwner(patientId) || (isMedicineStore() && isExistingDoc() && resource.data.medicineStoreId == request.auth.uid)) && isPatientLinkImmutable();
        allow delete: if isOwner(patientId);
      }

      match /data_consents/{consentId} {
          allow get: if isOwner(patientId) || (isDoctor() && consentId == request.auth.uid);
          allow list, create, update, delete: if isOwner(patientId);
      }
      
      match /allergies/{allergyId} {
        allow read, write: if isOwner(patientId);
      }
      
      match /chronic_conditions/{conditionId} {
        allow read, write: if isOwner(patientId);
      }
    }
    
    // -------------------------------------------------------------------------
    // Doctor Subcollection Rules (for denormalized data)
    // -------------------------------------------------------------------------
    match /doctors/{doctorId} {
        match /appointments/{appointmentId} {
            allow get, list: if isOwner(doctorId);
            allow create: if isOwner(doctorId) && linksToDoctorOnCreate(doctorId);
            allow update: if isOwner(doctorId) && isDoctorLinkImmutable();
            allow delete: if isOwner(doctorId);
        }

        match /consented_patients/{patientId} {
            // Doctors can read the list of patients who consented.
            allow get, list: if isOwner(doctorId);
            // Patients create/delete their own consent records here via denormalization.
            // The patient's ID must match the document ID.
            allow create, delete: if isPatient() && request.auth.uid == patientId;
        }
    }

    // -------------------------------------------------------------------------
    // Medicine Store Subcollection Rules (for denormalized data)
    // -------------------------------------------------------------------------
    match /medicine_stores/{storeId} {
        match /orders/{orderId} {
            allow get, list: if isOwner(storeId);
            allow create: if isOwner(storeId) && linksToStoreOnCreate(storeId);
            allow update: if isOwner(storeId) && isStoreLinkImmutable();
            allow delete: if isOwner(storeId);
        }
    }
  }
}
